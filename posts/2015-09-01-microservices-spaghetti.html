<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"><meta content="Johannes Staffans" itemprop="author" name="author"><title>Johannes Staffans - Stop the microservice spaghetti</title><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet"><link href="/styles/main.css" rel="stylesheet" type="text/css"></head><div><div class="header"><div class="header__content clearfix"><div class="sm-col sm-col-8"><div>personal website and blog of</div><h1 class="header__headline"><a href="/">Johannes Staffans</a></h1></div><div class="sm-col flex-column"><div><a href="/">posts</a><span> &middot; </span><a href="/pages/about.html">about</a></div><div class="pt1">elsewhere</div><div><a href="https://github.com/jstaffans">github</a><span> &middot; </span><a href="https://www.linkedin.com/in/jstaffans">linkedin</a><span> &middot; </span><a href="https://twitter.com/jstaffans">@jstaffans</a></div></div></div><div class="clearfix"><svg class="left border-triangle" version="1.1" xmlns="http://www.w3.org/2000/svg"><polygon class="mask" points="0,0 30,0 30,30 0,30"></polygon><polygon points="0,15 30,0 30,30"></polygon></svg><svg class="right border-triangle" version="1.1" xmlns="http://www.w3.org/2000/svg"><polygon class="mask" points="0,0 30,0 30,30 0,30"></polygon><polygon points="30,15 0,30 0,0"></polygon></svg></div></div><div class="container"><div><div class="flex items-baseline justify-between"><h2>Stop the microservice spaghetti</h2><div><span>01.09.2015</span></div></div><div><p>When moving from a monolithic architecture to microservices, you immediately appreciate the agility with which you can develop new functionality. It's easy to get over-enthusiastic and throw a microservice at any problem you have and not spend much time thinking about the bigger picture. The last thing you want to do is replace the monolithic spaghetti code with a distributed service spaghetti. Here are some of the lessons I've learned over the last year or so of working with microservices and some thoughts about what could have been solved in a better way.</p>
<p>The first thing to realise is that as soon as you start doing microservices, you have traded your monolithic problem for a distributed systems problem with implications for deployment, communication, monitoring and so on. All those things should be carefully thought about. I'm not going into details about deployment this time - suffice to say that microservices should be independently deployable and runnable, ideally as a self-contained thing.</p>
<h3><a href="#platform-versus-distributed-services" id="platform-versus-distributed-services"></a>Platform versus distributed services</h3>
<p>I recently watched a <a href="https://www.youtube.com/watch?v=yk_VlKUDKMA">talk</a> about microservices from GR8Conf 2015 that resonated very well with me. In the talk, two different kinds of microservice architectures are described: platforms and distributed service layers.</p>
<p><img src="/images/platform.png" alt="platform" /></p>
<p>A <strong>platform</strong> consists of vertically sliced microservices and a gateway layer responsible for orchestrating access to the services — the services themselves do not talk to each other but are instead completely self-contained. This includes having their own domain models, which can be shared with the gateway layer via e.g. a client library, a set of Protobuf message types or something else. The gateway layer is responsible for discoverability and in case of failure, should let any clients know that a particular service is not available. HATEOAS is one way of accomplishing this, the gateway providing a service map as part of its API:</p>
<pre><code class="highlight"><span></span><span class="p">{</span>
    <span class="nt">"_links"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">"rel"</span><span class="p">:</span> <span class="s2">"product.reviews"</span><span class="p">,</span>
            <span class="nt">"href"</span><span class="p">:</span> <span class="s2">"/reviews{?productId}"</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="nt">"rel"</span><span class="p">:</span> <span class="s2">"product.users"</span><span class="p">,</span>
            <span class="nt">"href"</span><span class="p">:</span> <span class="s2">"/users"</span>
        <span class="p">}</span>
        <span class="err">...</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>In a platform architecture, the functionality of various backend services is combined in order to produce a response to a client request. Another kind of microservice architecture is the <strong>distributed service layer</strong> approach, where services are acting more or less individually in order to accomplish business goals. They may be called by a higher-layer API, by other microservices or maybe directly by clients. This is the case that can easily turn into spaghetti if you are not careful about the interactions between services.</p>
<h4><a href="#decoupled-distributed-services" id="decoupled-distributed-services"></a>Decoupled distributed services</h4>
<p>It's useful to strive for a tree-like architecture, with higher-level services calling lower-level ones in a sort of <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a>. Anything else will lead to high coupling between services. It's also useful to organise services into two rough camps - services that produce data and other services that consume data.</p>
<p><img src="/images/distributed-services.png" alt="platform" /></p>
<p>The clients of a particular service should be responsible for understanding its API and provide data in a format that the service expects. API versioning and good documentation help here — sharing a domain model is not such a good idea, because the landscape is more dynamic with any service being able to call basically any other service in the topography.</p>
<p>The above diagram sort of implies RPC being the method of communication between services. In my mind, RPC should however be avoided whenever possible. Communicating using queues (for services where latency is not such a big deal, such an email sending service) or with some distributed messaging scheme should be greatly preferred, because it further decouples services from each other. If you are worried about introducing further overhead in the form of a central message broker, have a look at what your platform already offers — in an AWS landscape, for example, it's possible to build a pub/sub architecture using SQS and SNS. It can be <a href="https://github.com/meducation/propono">beautifully simple</a>.</p>
<p>As the bane of distributed service communication, look no further than shared database schemas. This introduces extreme coupling between services and makes maintaining the database schema very hard. Avoid at all costs!</p>
<h3><a href="#conclusion" id="conclusion"></a>Conclusion</h3>
<p>This post was more or less a brain dump of my thoughts on how to architect a microservice-based backend. I hope it can work as food for though for anyone embarking on a similar venture. As with any fancy information system, microservices aren't a silver bullet but proper design and some forethought can enable you to reap their full benefit in terms of speed of development, testability and scalability.</p>
</div><div><a href="/">Back</a></div></div></div><div class="footer"><p>&copy; 2015-2018 Johannes Staffans</p></div></div></html>
